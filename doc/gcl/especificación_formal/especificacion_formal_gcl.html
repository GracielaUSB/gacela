<!DOCTYPE doctype HTML>
<html>
 <head>
  <meta charset="utf-8">
   <title>
    Made with Remarkable
   </title>
   <link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet">
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
    </script>
    <script>
     hljs.initHighlightingOnLoad();
    </script>
    <style type="text/css">
     body{font:16px Helvetica,Arial,sans-serif;line-height:1.4;color:#333;word-wrap:break-word;background-color:#fff;padding:10px 15px}strong{font-weight:700}h1{font-size:2em;margin:.67em 0;text-align:center}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h1,h2,h3,h4,h5,h6{font-weight:700;position:relative;margin-top:15px;margin-bottom:15px;line-height:1.1}h1,h2{border-bottom:1px solid #eee}hr{height:0;margin:15px 0;overflow:hidden;background:0 0;border:0;border-bottom:1px solid #ddd}a{color:#4183C4}a.absent{color:#c00}ol,ul{padding-left:15px;margin-left:5px}ol{list-style-type:lower-roman}table{padding:0}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0;padding:0}table tr:nth-child(2n){background-color:#aaa}table tr th{font-weight:700;border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td{border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td :first-child,table tr th :first-child{margin-top:0}table tr td:last-child,table tr th :last-child{margin-bottom:0}img{max-width:100%}code{padding:0 5px;background-color:#d3d3d3}blockquote{padding: 0 15px;border-left:4px solid #ccc}
    </style>
   </link>
  </meta>
 </head>
 <body>
  <h1>
   Especificación Formal de GCL
  </h1>
  <h2>
   Introducción
  </h2>
  <h2>
   Especificación de programas
  </h2>
  <p>
   Los programas en GCL mantienen la siguiente estructura:
  </p>
  <pre><code>[
    &lt;declaracion de constantes&gt;
    &lt;declaracion de variables&gt;
    {Precondicion}
    &lt;lista de instrucciones&gt;
    {Postcondicion}
]
</code></pre>
  <h2>
   Declaración de constantes y  variables
  </h2>
  <p>
   Las constantes y variables definen el espacio de estados sobre el que trabajará el programa. Éstas asocian un nombre a un tipo de datos.
  </p>
  <p>
   Los tipos de datos son conjuntos de valores que cuentan con operaciones definidas. El lenguaje GCL consta de los siguientes:
  </p>
  <ul>
   <li>
    Enteros (int): Está conformado por los números énteros.
   </li>
   <li>
    Reales (float): Contiene a los números reales.
   </li>
   <li>
    Lógicos (boolean): Lo conforman los valores lógicos True y False.
   </li>
   <li>
    Caracteres (char): Incluye a todas las letras del alfabeto latino, tanto en su forma mayúscula como minúscula.
   </li>
   <li>
    Secuencia de valores: Podemos definirlo como una función sobre un subconjunto consecutivo de los números enteros a un conjunto de valores pertenecientes a otro tipo del lenguaje. Sean p &lt;= q, tales que p &lt;= i &lt; q y denotamos [p,q) como la secuencia consecutiva de todos los
    <em>
     i
    </em>
    . La declaración:
    <strong>
     <em>
      f : secuencia [p,q) de enteros
     </em>
    </strong>
    , define una variable con una función asociada: [p,q) -&gt; Z.
   </li>
  </ul>
  <p>
   El valor asociado a una variable declarada constante no puede cambiar durante la ejecución del programa.
  </p>
  <h2>
   Precondicion y postcondición
  </h2>
  <p>
   Las precondición y postcondición son expresiones lógicas que expresan las condiciones que satisface el espacio de estados de entrada y salida, respectivamente.
  </p>
  <p>
   Las expresiones lógicas estás conformada por operadores lógicos y cuantificadores.
  </p>
  <h3>
   Operdores Lógicos
  </h3>
  <p>
   Incluye aquellos operadores definidos sobre los valores lógicos
   <em>
    True
   </em>
   y
   <em>
    False
   </em>
   . Entre estos tenemos:
   <br/>
   - ∧ (conjunción)    = E.
   <br/>
   - ∨ (disjunción)    =.
   <br/>
   - ≡ (equivalencia)  =.
   <br/>
   - ⇒ (implicacion)   =.
   <br/>
   - ¬ (negación)      =.
  </p>
  <h2>
   Intrucciones
  </h2>
  <h3>
   Skip
  </h3>
  <p>
   La ejecución de la instrucción
   <strong>
    skip
   </strong>
   no tiene efecto alguno en el estado actual de las variables.
  </p>
  <h3>
   Asignación
  </h3>
  <p>
   Cualquier cambio en el estado del programa es debido a la ejecución de una intrucción de asignación.
  </p>
  <p>
   La asignación es de la forma
  </p>
  <blockquote>
   <pre><code>  x := E
</code></pre>
   <p>
    Donde x es una variable del programa y E es una expresión del mismo tipo de E.
   </p>
  </blockquote>
  <p>
   Operacionalmente, su interpretación es: reemplaza el valor de la variable x por el valor de E.
  </p>
  <h3>
   Secuenciación
  </h3>
  <p>
   La secuenciación permite definir un orden de ejecución de acciones.
  </p>
  <p>
   Se denota por
  </p>
  <blockquote>
   <pre><code>  S;T
</code></pre>
  </blockquote>
  <p>
   Y se interpreta de la siguiente forma: S es ejecutada primero e inmediatamente comienza la ejecución de T.
  </p>
  <h3>
   Selección
  </h3>
  <p>
   Se escribe de la siguiente forma:
  </p>
  <blockquote>
   <p>
    <strong>
     if B
     <sub>
      0
     </sub>
     -&gt; S
     <sub>
      0
     </sub>
     [] ... [] B
     <sub>
      n
     </sub>
     -&gt; S
     <sub>
      n
     </sub>
     fi
    </strong>
    <br/>
    En la cual, 0&lt;= i &lt;= n,
    <em>
     B
     <sub>
      i
     </sub>
    </em>
    es una guardia (expresión lógica) y
    <em>
     S
     <sub>
      i
     </sub>
    </em>
    es una instrucción. Ademas, las construcciones
    <em>
     B
     <sub>
      i
     </sub>
     -&gt; S
     <sub>
      i
     </sub>
    </em>
    son llamadas
    <strong>
     comandos guardados
    </strong>
    (guarded commands).
   </p>
  </blockquote>
  <p>
   Podemos interpretar la selección de la siguiente manera: Al momento de la ejecución todas las guardias son evaluadas, si ninguna de las guardias es cierta el programa aborta; en caso contrario, una de las guardias que evaluaron a cierto es seleccionada de manera
   <em>
    no determínistica
   </em>
   y la instrucción correspondiente es ejecutada.
  </p>
  <h3>
   Iteración
  </h3>
  <p>
   La iteración nos permite seleccionar acciones que pueden ser ejecutadas una o más veces.
  </p>
  <p>
   Tiene la forma:
  </p>
  <blockquote>
   <p>
    <strong>
     do B
     <sub>
      0
     </sub>
     -&gt; S
     <sub>
      n
     </sub>
     [] ... [] B
     <sub>
      n
     </sub>
     -&gt; S
     <sub>
      n
     </sub>
    </strong>
    <br/>
    donde, 0&lt;= i &lt;= n,
    <em>
     B
     <sub>
      i
     </sub>
    </em>
    es una guardia y
    <em>
     S
     <sub>
      i
     </sub>
    </em>
    es una acción del lenguaje.
   </p>
  </blockquote>
  <p>
   Se puede interpretar de la siguiente manera:
  </p>
  <p>
   Al momento de la ejecucion, se evaluan todas las guardias. Si todas las guardias evaluan a falso, entonces se ejecuta la instruccion
   <strong>
    skip
   </strong>
   ; en caso contrario, una de las guardias que evaluó a cierto es seleccionada de forma
   <em>
    no deterministica
   </em>
   y su accion correspondiente es ejecutada. Posteriormente la iteración es ejecutada de nuevo.
  </p>
  <h3>
   Definición formal de la gramática
  </h3>
  <p>
   Definiremos la semántica de una acción a través de la regla logica que cumple y precondición más débil que debe cumplir
   <br/>
   un conjunto de estados para cumplir la postcondión deseada.
  </p>
  <h3>
   Skip
  </h3>
  <p>
   Regla:
  </p>
  <blockquote>
   <p>
    <strong>
     {P} skip {Q} es equivalente a {P =&gt; Q}
    </strong>
   </p>
  </blockquote>
  <p>
   En terminos de la precondición mas debil:
  </p>
  <blockquote>
   <p>
    <strong>
     wp(skip,Q) == Q
    </strong>
   </p>
  </blockquote>
  <h3>
   Asignación
  </h3>
  <p>
   Regla:
  </p>
  <blockquote>
   <p>
    <strong>
     {P} x:= E {P =&gt; Q(x:=E)}
    </strong>
   </p>
  </blockquote>
  <p>
   En terminos de la precondición mas débil:
  </p>
  <blockquote>
   <p>
    <strong>
     wp(x:=E, Q) == Q(x:=E)
    </strong>
   </p>
  </blockquote>
  <h3>
   Secuenciación
  </h3>
  <p>
   Para probar su validez debemos encontrar un predicado R el cual
   <strong>
    <em>
     {P} S {R}
    </em>
   </strong>
   y
   <strong>
    <em>
     {R} T {Q}
    </em>
   </strong>
   son ciertos. La ejecucion de S en el estado que satisface P termina en un estado R, y la ejecucion de T en el estado que cumple R termina en un estado que satisface Q.
  </p>
  <p>
   Por lo cual terminamos con la siguiente regla:
  </p>
  <blockquote>
   <p>
    <strong>
     {P} S;T {Q}
    </strong>
    <br/>
    es equivalente a
    <br/>
    existe un predicado R para el cual
    <br/>
    <strong>
     {P} S {T} y {R} T {Q}
    </strong>
   </p>
  </blockquote>
  <p>
   En terminos de la precondición más débil
  </p>
  <blockquote>
   <p>
    <strong>
     wp((S;T),Q) == wp(S, wp(T,Q))
    </strong>
   </p>
  </blockquote>
  <p>
   Se puede interpretar de la siguiente forma: La precondición más débil que satisface
   <strong>
    {P} S;T {Q}
   </strong>
   se obtiene encontrando el R mas débil tal que
   <strong>
    {R} T {Q}
   </strong>
   es verdadero, que luego es usado como postcondición para encontrar el P más débil tal que {P} S {R}.
  </p>
  <h3>
   Selección
  </h3>
  <p>
   Ahora podemos definir la regla de deduccion:
  </p>
  <blockquote>
   <p>
    <strong>
     {P} if B
     <sub>
      0
     </sub>
     -&gt; S
     <sub>
      i
     </sub>
     [] ... [] B
     <sub>
      n
     </sub>
     -&gt; S
     <sub>
      n
     </sub>
     fi {Q}
    </strong>
    <br/>
    es equivalente a
    <br/>
    <strong>
     P =&gt; B
     <sub>
      0
     </sub>
     V ... V B
     <sub>
      n
     </sub>
    </strong>
    <br/>
    y
    <br/>
    <strong>
     {P /\ B
     <sub>
      0
     </sub>
     } S
     <sub>
      0
     </sub>
     {Q} /\ ... /\  {P /\ B
     <sub>
      n
     </sub>
     } S
     <sub>
      n
     </sub>
     {Q}
    </strong>
   </p>
  </blockquote>
  <p>
   En terminos de la precondición más débil:
  </p>
  <blockquote>
   <p>
    <strong>
     wp (if B
     <sub>
      0
     </sub>
     -&gt; S
     <sub>
      0
     </sub>
     [] ... [] B
     <sub>
      n
     </sub>
     -&gt; S
     <sub>
      n
     </sub>
     , Q)
    </strong>
    <br/>
    es equivalente a
    <br/>
    <strong>
     (B
     <sub>
      0
     </sub>
     \/ ... \/ B
     <sub>
      n
     </sub>
     ) /\ (B0 =&gt; wp(S
     <sub>
      0
     </sub>
     ,Q) /\ ... /\ wp(S
     <sub>
      n
     </sub>
     , Q))
    </strong>
   </p>
  </blockquote>
  <h3>
   Iteración
  </h3>
  <p>
   Reglas
  </p>
 </body>
</html>