
/*% LANGUAGE MemoryOperations  %*/
/*% LANGUAGE EnableTrace  %*/
/*% LANGUAGE NoAssertions  %*/

include "Memory"

module String begin

  abstract StringA begin
    /* asd variables */
    {repinv true repinv}
    /* asd procedures and functions */
  end

  type String implements StringA begin
    /* String variables */
    var size  : int;
    var s     : char*;
    
    {repinv true repinv}

    {coupinv true coupinv}
    
    /* a procedures and functions */
 
    proc readString(ref str : String)
      {pre  true  pre}
      {post str.s != null post}
      |[ if str.s != null -> writeln("Free 3>"); free(str.s) 
         [] otherwise -> skip
         fi;
         str.s := readln(&str.size);
      ]|
    
    proc writeString(in str : String)
      {pre  str.s != null  pre}
      {post true post}
      |[ var i := 0 : int;
        if (str.s == null) -> skip
        [] otherwise ->
            {inv str.s[i] == '\0' ==> i == str.size inv}
            {bound str.size - i  bound}
            do i < str.size /\ str.s[i] != '\0' ->
              write(str.s[i]);
              i := i+1;
            od
        fi

      ]|
    proc delete (ref str : String)
      {pre  true  pre}
      {post true post}
      |[ 
        if (str.s == null) -> skip
        [] otherwise       -> free(str.s);
        fi
      ]|
    proc copy(ref str : String, in s : char*)
      {pre  true  pre}
      {post true post}
      |[ var i := 0 : int;
         var m : Mem(char);

        if (str.s == null) -> skip
        [] otherwise -> writeln("Free 2>"); free(str.s); str.s := null;
        fi;

        {inv true inv}
        {bound MAX_INT - str.size  bound}
        do s[str.size] != '\0' ->
          str.size := str.size+1;
        od;
        malloc(m, str.size+1, str.s);

        {inv s[i] == '\0' ==> i == str.size inv}
        {bound str.size - i  bound}
        do i < str.size /\ s[i] != '\0' ->
          str.s[i] := s[i];
          i := i+1;
        od;
      ]|

    proc concat(ref str1 : String, ref str2 : String)
      {pre  str1.s != null /\ str2.s != null  pre}
      {post true  post}
      |[  var i, oldSize := 0, str1.size : int;
          var m : Mem(char);
          var c := str1.s : char*;
          str1.size := oldSize + str2.size;

          malloc (m, str1.size + 1, str1.s);
          
          {inv c[i] == '\0' ==> i == oldSize inv}
          {bound oldSize - i  bound}
          do i < oldSize /\ c[i] != '\0' ->
            str1.s[i] := c[i];
            i := i+1;
          od;

          i := 0;
          {inv str2.s[i] == '\0' ==> i == str2.size inv}
          {bound str2.size - i  bound}
          do i < str2.size /\ str2.s[i] != '\0' ->
            str1.s[i+oldSize] := str2.s[i];
            i := i+1;
          od;
          str1.s[str1.size+1] := '\0';
          free(c)

      ]|
  end
end