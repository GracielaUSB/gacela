
/*% LANGUAGE MemoryOperations %*/



include "String"

program Program begin

abstract ListA(T)
begin
  /* ListA Tariables */
  var seq : sequence of T;
  {repinv true repinv}
  /* ListA Trocedures and functions */
  proc push_back (ref list : ListA(T), in e : T)
    {pre true pre}
    {post #list.seq == #list'.seq+1 /\ list.seq[#list.seq-1] == e post}
end

type List(T) implements ListA(T)
begin
  /* List variables */
  var size := 0 : int;
  var max_size := 0 : int;
  var elems := null : T*;
  var m : Mem(T);

  {repinv elems == null ==> size == 0 repinv}
  {coupinv true coupinv}
  where {
    seq := << i : int | 0 <= i /\ i < size | elems[i] >>
  }

  /* List procedures and functions */
  proc push_back (ref list : List(T), in e : T)
    {pre true pre}
    {post list.size == list'.size + 1 /\ list.elems[list.size-1] == e post}
    |[ 
      if list.max_size == 0 -> 

        malloc (list.m, 2, list.elems);
        list.max_size := 2;
      [] list.size == list.max_size -> 
        var aux : T*;
        var i := 0 : int;

        list.max_size := list.max_size * 2;
        malloc(list.m, list.max_size, aux);
        {inv true inv}
        {bound list.size - i bound}
        do i < list.size ->
          aux[i] := list.elems[i];
          i := i+1;
        od;
        free(list.elems);
        list.elems := aux
      [] otherwise -> skip
      fi;
      list.elems[list.size] := e;
      list.size := list.size + 1
    ]|

  proc showList (ref list : List(T))
    {pre  true  pre}
    {post true post}
    |[ var i := 0 : int;
       {inv true inv}
       {bound list.size - i bound}
       do i < list.size ->
         write(list.elems[i]);
         i := i+1;
       od;
      writeln()
    ]|

  proc deleteList (ref list : List(T))
    {pre  true  pre}
    {post true post}
    |[  free(list.elems); 
    ]|

end

alias StringB := List(char);

proc readFile (ref str : StringB)
  {pre  true  pre}
  {post true post}
  |[ var c := ' ' : char 
   ; {inv true inv}
     {bound 1 bound}
     do c != '\0' -> read(c) from "hola.t"; push_back(str, c) od
  ]|

alias Tokens := List(StringB*);

proc deleteListTokens (ref list : Tokens)
    {pre  true  pre}
    {post true post}
    |[ if list.elems != null ->
          var i := 0 : int
          ; {inv true inv}
            {bound 1 bound}
            do i < list.size -> 
              if list.elems[i] != null -> 
                deleteList(*list.elems[i]);
                free(list.elems[i])
              [] otherwise -> skip
              fi;
              i := i + 1;
            od;
          free(list.elems)
       [] otherwise -> skip
       fi
    ]|

proc tokenizer (in str : StringB, out tokens : Tokens)
  {pre  true  pre}
  {post true post}
  |[ 
    skip
  ]|

main
  |[ 
    var str  : StringB*;
    var t  : Tokens;
    var v : array[2,2,2] of array[10,10] of array[2,2] of int;
    v[1,1,1][9,9][1,1] := 1010101;
    writeln(v[1,1,1][9,9][1,1]);
    new(str);
    readFile(*str);
    showList(*str);
    push_back(t, str);
    showList(*t.elems[0]);
    deleteListTokens(t);
    skip
  ]|
end