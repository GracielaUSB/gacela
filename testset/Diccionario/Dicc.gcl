/**
 * Implementacion del TDA Diccionario
 **/

include "Diccionario"


module Dicc begin

  /**
   * Para implementar el tipo de dato abstracto Diccionario,
   * se utilizan dos arreglos de tamaño MAX, de tipo T0 y T1 
   * representa los conjuntos de claves y valores respectivamente.
   * Ademas, se declara una variable para almacenar el tamaño 
   * actual de los arreglos.
   **/
  type Dicc(T0, T1) implements Diccionario(T0, T1) begin
    var clave : array [MAX] of T0;
    var valor : array [MAX] of T1;
    var tam   : int;

    /**
     * El tamaño debe encontrarse en el rango [0,MAX] y 
     * todas las claves deben ser distintas entre si.
     **/
    {repinv MAX > 0 ∧ 0 ≤ tam ∧ tam ≤ MAX ∧
      (% ∀ i : int | 0 ≤ i ∧ i < tam
        | (% ∀ j : int | 0 ≤ j ∧ j < tam ∧ i != j | clave[i] != clave[j] %)
      %)
    repinv}

    {coupinv true coupinv}

    /**
     * La tabla del diccionario se construye con una funcion biyectiva 
     * que va de cada elemento del arreglo de claves a un elemento del 
     * arreglo de los valores.
     * Asi mismo, el conjunto de claves conocidas es un conjunto con 
     * todos los valores del arreglo de claves.
     **/
    where { 
      tabla := func({i : int | 0 ≤ i ∧ i < tam | (clave[i], valor[i])});
      conoc := {i : int | 0 ≤ i ∧ i < tam | clave[i]}
    }
    

    proc agregar (inout d : Dicc(T0,T1), in c : T0, in v : T1)
      {pre ¬(% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c %) 
          ∧ d.tam < d.MAX 
      pre}

      {post d.tam == d'.tam + 1 
          ∧ d.clave[d'.tam] == c ∧  d.valor[d'.tam] == v 
          ∧ (% ∀ i : int | 0 ≤ i ∧ i < d'.tam | d.clave[i] == d'.clave[i]
                                              ∧ d.valor[i] == d'.valor[i] %) 
      post}
      
      ⟦ var i := 0 : int
      ; if d.tam == 0 -> d.clave[d.tam], d.valor[d.tam] := c, v
                       ; d.tam := d.tam + 1
        [] otherwise -> 
            {inv 0 ≤ i ∧ i ≤ d.tam inv}
            {bound d.tam - i bound} 
            do i < d.tam -> 
              if d.clave[i] == c -> i := d.tam
              [] i == d.tam - 1  -> d.clave[d.tam], d.valor[d.tam] := c, v
                                 ; d.tam := d.tam + 1
                                 ; i := d.tam
              [] otherwise       -> i := i + 1
              fi
            od
        fi
      ⟧


    proc eliminar (inout d : Dicc(T0,T1), in c : T0)
      var k : int;

      {pre (% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c %) pre}
      {post d.tam == d'.tam - 1
           ∧ (% ∃ i : int | 0 ≤ i ∧ i < d'.tam | 
                d'.clave[i] == c
              ∧ d.clave[i] == d'.clave[d'.tam-1]
              ∧ d.valor[i] == d'.valor[d'.tam-1]
              ∧ (% ∀ j : int | 0 ≤ j ∧ j < d.tam-1 ∧ j != i |
                  d.clave[j] == d'.clave[j] ∧ d.valor[j] == d'.valor[j] %) %) 
      post}

      ⟦ var i := 0 : int
      ; {inv 0 ≤ i ∧ i ≤ d.tam inv}
        {bound d.tam - i  bound} 
        do i < d.tam -> 
          if d.clave[i] != c -> i := i + 1
          [] d.clave[i] == c -> d.clave[i] := d.clave[d.tam - 1]
                              ; d.valor[i] := d.valor[d.tam - 1]
                              ; i := d.tam
          fi
        od
      ; writeln(d.tam)
      ; d.tam := d.tam - 1
      ; writeln(d.tam)
      ⟧

    proc buscar ( in d : Dicc(T0,T1), in c : T0 , out v : T1 )
      {pre  (% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c %) pre}
      {post (% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c 
                                             ∧ d.valor[i] == v %) post}
      ⟦ var i := 0 : int
      ; {inv 0 ≤ i ∧ i ≤ d.tam inv}
        {bound d.tam - i bound} 
        do i < d.tam -> 
          if d.clave[i] != c -> i := i+1
          [] otherwise       -> v, i := d.valor[i], d.tam
          fi
        od
      ⟧

    proc existe (in d : Dicc(T0,T1), in c : T0, out e : boolean)
      {pre true pre}
      {post e ≡ (% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c %) post}
      ⟦ var i := 0 : int
      ; e := false
      ; {inv 0 ≤ i ∧ i ≤ d.tam inv}
        {bound d.tam - i bound} 
        do i < d.tam /\ e -> 
          if d.clave[i] != c -> i := i+1
          [] otherwise -> e := true
          fi
        od
      ⟧

    proc mostrar (in d : Dicc(T0,T1))
      {pre  true  pre}
      {post true post}
      ⟦ var i := 0 : int
      ; {inv 0 ≤ i ∧ i ≤ d.tam inv}
        {bound d.tam - i bound} 
        do i < d.tam -> 
          writeln(d.clave[i], " -> ", d.valor[i]);
          i := i + 1
        od
    
      ⟧
  end
end