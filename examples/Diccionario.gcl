program Dicc.bin begin

abstract Diccionario (T0, T1) begin
  const MAX := 100 : int;
  var conoc : set of T0;
  var tabla : function T0 -> T1;

  {inv MAX > 0 ∧ #conoc ≤ MAX ∧ conoc == domain(tabla) inv}  
  
  proc crear (in m : int, out d : Diccionario(T0,T1))
    {pre m > 0 pre}
    {post d.MAX == m ∧ d.conoc == ∅ ∧ d.tabla == func(∅) post}

  proc agregar (inout d : Diccionario(T0,T1), in c : T0, in v : T1)
    var tabla' := d.tabla : function T0 -> T1;
    var conoc' := d.conoc : set of T0;

    {pre c ∉ d.conoc ∧ #d.conoc < d.MAX pre}
    {post d.conoc == conoc' ∪ {c}
        ∧ d.tabla == tabla' ∪ func({(c, v)}) post}

  proc eliminar (inout d : Diccionario(T0,T1), in c : T0)
    var tabla' := d.tabla : function T0 -> T1;
    var conoc' := d.conoc : set of T0;
   
    {pre c ∈ d.conoc pre}
    {post d.conoc == conoc' \ {c} 
        ∧ d.tabla == tabla' \ func({(c, tabla'(c))}) post}

  proc buscar (in d : Diccionario(T0,T1), in c : T0, out v : T1)
    {pre  c ∈ d.conoc  pre}
    {post v == d.tabla(c) post}

  proc existe (in d : Diccionario(T0,T1), in c : T0, out e : boolean)
    {pre true pre}
    {post e ≡ c ∈ d.conoc post}
end


type Dicc(T0, T1) implements Diccionario(T0, T1) begin
  var   clave      : array [MAX] of T0;
  var   valor      : array [MAX] of T1;
  var   tam        : int;

  {repinv MAX > 0 ∧ 0 ≤ tam ∧ tam ≤ MAX ∧
    (% ∀ i : int | 0 ≤ i ∧ i < tam
      | (% ∀ j : int | 0 ≤ j ∧ j < tam ∧ i != j | clave[i] != clave[j] %)
    %)
  repinv}

  {coupinv true coupinv}

  where { 
    conoc := {i : int | 0 ≤ i ∧ i < tam | clave[i]};
    tabla := func({i : int | 0 ≤ i ∧ i < tam | (clave[i], valor[i])})
  }
  
  proc copiarClaveValor ( in d       : Dicc(T0,T1)
                        , const m    : int
                        , out clave' : array[m] of T0
                        , out valor' : array[m] of T1)
    {pre true pre}
    {post (% forall i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == clave'[i] 
                                                ∧ d.valor[i] == valor'[i]  %) post}
    ⟦ var i : int
    ; i := 0
    ; {inv 0 ≤ i ∧ i ≤ d.tam inv}
      {bound d.tam - i bound} 
      do i < d.tam -> clave'[i] := d.clave[i]
                    ; valor'[i] := d.valor[i]
                    ; i := i + 1

      od 
    ⟧

  proc crear (in m : int, out d : Dicc(T0,T1))
    {pre    true     pre}
    {post d.tam == 0 post}
    ⟦ d.tam := 0 ⟧

  proc agregar (inout d : Dicc(T0,T1), in c : T0, in v : T1)
    var tam' := d.tam : int;  
    var clave'        : array[d.MAX] of T0;
    var valor'        : array[d.MAX] of T1;

    {pre ¬(% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c %) ∧ d.tam < d.MAX pre}

    {post d.tam == tam' + 1 ∧ d.clave[tam'] == c ∧  d.valor[tam'] == v 
              ∧ (% forall i : int | 0 ≤ i ∧ i < tam' | d.clave[i] == clave'[i]
                                                     ∧ d.valor[i] == valor'[i] %) post}
    ⟦ var i : int
    ; copiarClaveValor(d, d.MAX, clave', valor')
    ; i := 0
    
    ; if d.tam == 0 -> d.clave[d.tam], d.valor[d.tam] := c, v
                     ; d.tam := d.tam + 1
      [] otherwise 
          -> {inv 0 ≤ i ∧ i ≤ d.tam inv}
             {bound d.tam - i bound} 
             do i < d.tam -> if d.clave[i] == c -> i := d.tam
                             [] i == d.tam - 1  -> d.clave[d.tam], d.valor[d.tam] := c, v
                                                 ; d.tam := d.tam + 1
                                                 ; i := d.tam
                             [] otherwise       -> i := i + 1
                             fi
             od
      fi
    ⟧

  proc eliminar (inout d : Dicc(T0,T1), in c : T0)
    var tam' := d.tam : int;
    var k             : int;
    var clave'        : array[d.MAX] of T0;
    var valor'        : array[d.MAX] of T1;

    {pre (% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c %) pre}
    {post d.tam == tam' - 1
         ∧ (% ∃ i : int | 0 ≤ i ∧ i < tam' | 
               clave'[i] == c
            ∧ d.clave[i] == clave'[tam'-1]
            ∧ d.valor[i] == valor'[tam'-1]
            ∧ (% forall j : int | 0 ≤ j ∧ j < d.tam-1 ∧ j != i |
                     d.clave[j] == clave'[j] 
                   ∧ d.valor[j] == valor'[j] %) %) post}
    ⟦ var i := 0 : int
    ; copiarClaveValor(d, d.MAX, clave', valor')

    ; {inv 0 ≤ i ∧ i ≤ d.tam inv}
      {bound d.tam - i  bound} 
      do i < d.tam -> if d.clave[i] != c -> i := i + 1
                      [] d.clave[i] == c -> d.clave[i] := d.clave[d.tam - 1]
                                          ; d.valor[i] := d.valor[d.tam - 1]
                                          ; i := d.tam
                      fi
      od
    ; writeln(d.tam)
    ; d.tam := d.tam - 1
    ; writeln(d.tam)
    ⟧

  proc buscar ( in d : Dicc(T0,T1), in c : T0 , out v : T1 )
    {pre  (% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c %) pre}
    {post (% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c ∧ d.valor[i] == v %) post}
    ⟦ var i : int
    ; i := 0
      
    ; {inv 0 ≤ i ∧ i ≤ d.tam inv}
      {bound d.tam - i bound} 
      do i < d.tam -> if d.clave[i] != c -> i := i+1
                      [] otherwise       -> v, i := d.valor[i], d.tam
                      fi
      od
    ⟧

  proc existe (in d : Dicc(T0,T1), in c : T0, out e : boolean)
    {pre true pre}
    {post e ≡ (% ∃ i : int | 0 ≤ i ∧ i < d.tam | d.clave[i] == c %) post}
    ⟦ var i : int
    ; i := 0
    ; e := false
    ; {inv 0 ≤ i ∧ i ≤ d.tam inv}
      {bound d.tam - i bound} 
      do i < d.tam -> if d.clave[i] != c -> i := i+1
                      [] otherwise       -> e, i := true, d.tam
                      fi
      od
    ⟧
end

func constante (i : int) ->  int
  {pre  true pre}
  {post  true post}
  |[
    1
  ]|

func rec ( i : int) -> int
  {pre  true   pre}
  {post true post}
  {bound i bound}
  |[ if i >= constante(i) -> rec(i-1)*2
     [] otherwise -> 1
     fi
  ]|

main
  |[ var d : Dicc(int, int)
   ; var b : boolean
   ; var r : char
   ; var a : int*
   ; skip
   ; write(d.MAX)
   ; crear(100,d)
   ; agregar(d, 1, 2)
   ; agregar(d, 2, 1)
   ; agregar(d, 3, 4)
   ; existe(d,1,b)
   ; new(a)
   ; buscar(d,1,*a) 
   ; writeln(b, " -> ", *a)
   ; eliminar(d,3)
   ; writeln("Jamon = ",rec(2))
   
   ; existe(d,1,b)
   ; if     b     -> buscar(d,2,*a) 
                   ; writeln(b, " ->", *a)
     [] otherwise -> writeln("Soy estupido, no hay 1") 
     fi
  ]|
end