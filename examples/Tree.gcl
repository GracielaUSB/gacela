program Tree.bin begin

abstract ANode(T)
begin
  {inv true inv}   
end


func isLeft (i : int) -> boolean
  {pre i > 0  pre}
  {post true post}
  |[ if i == 1 -> false
     [] i == 2 -> true
     [] isLeft (i / 2)
     fi ]|


type Node(T) implements ANode(T)
begin
  /* Node variables */
  var element : T;
  var left, right : Node(T)*;

  {repinv true repinv}

  {coupinv true coupinv}

  func hasNode (node : Node(T)*, n : int, i : int) -> boolean
    {pre  true  pre}
    {post true post}
    |[ if node == null -> false
       [] i == n       -> true 
       [] isLeft (i)   -> hasNode ((*node).left,  n * 2,     i)
       [] otherwise    -> hasNode ((*node).right, n * 2 + 1, i) 
       fi ]|

  func getNode (node : Node(T)*, n : int, i : int) -> T
    {pre hasNode (node, i) pre}
    {post       true      post}
    |[ if node == null -> abort
       [] i == n       -> (*node).element 
       [] isLeft (i)   -> getNode ((*node).left,  n * 2,     i)
       [] otherwise    -> getNode ((*node).right, n * 2 + 1, i) 
       fi ]|

  /* Node procedures */
  func elemNode (current : Node(T)*, x : T, b : int) ->  boolean
     {pre  true  pre}
     {post true post}
     {bound b bound}
     |[
      if current == null -> false
      [] (*current).element == x -> true
      [] otherwise -> elemNode((*current).left, x , b-1) \/ elemNode((*current).right, x , b-1)
      fi
     ]| 

  proc print (in current : Node(T)*, in b : int)  
    {pre true pre}
    {post true post}
    {bound b bound}
    |[ if current == null -> skip
       [] current != null 
         -> print((*current).left, b-1)
          ; writeln((*current).element)
          ; print((*current).right, b-1) 
            
       fi
      
    ]|
end


abstract ATree(T)
begin
  /* ATree variables */
  const MAX := 100 : int;
  var   nodes : func int -> T;
  var   leftChild  : func int -> int
  var   rightChild : func int -> int
  {inv card(nodes) <= MAX inv}
  /* ATree procedures */
end

type BinaryTreeO(T) implements ATree(T)
begin
  /* BinaryTree variables */
  var tam := 0 : int;
  var root     : Node(T)*;
  
  {repinv 0 <= tam /\ tam <= MAX /\ (root == null ==> tam == 0) repinv}

  where { nodes := func({ i : int | 1 <= i /\ i <= MAX /\ hasNode(root, 1, i) | (i, getNode(root, 1, i)) }) 
        ; leftChild  := func ({ i : int | i elem domain(nodes) /\ (i * 2)     elem domain (nodes) | (i, i * 2) })
        ; rightChild := func ({ i : int | i elem domain(nodes) /\ (i * 2 + 1) elem domain (nodes) | (i, i * 2 + 1) }) 
        }

  /* BinaryTree procedures */
  func chao (x : int) -> int
    {pre  true pre}
    {post  true post}
    |[
      1
    ]|
  proc hola (in x : int)
  
    {pre true pre}
    {post true post}
    |[
      write("Soy un simpatico nÃºmero: ", x)
    ]|

  proc insert (inout t : BinaryTreeO(T), in x : T)
  
    {pre true pre}
    {post elemNode(t.root, x, t.tam) post}
    |[ if t.root == null 
          -> new(t.root)
           ; (*t.root).element := x
       [] otherwise 
          -> var aux := t.root : Node(T)*
           ; var i   := 0      : int
           ; {inv true inv}
             {bound t.tam - i bound}
             do i < t.tam 
              -> if x <= (*aux).element
                    -> if (*aux).left == null
                          -> new((*aux).left) 
                           ; (*(*aux).left).element, i := x, t.tam-1
                       [] otherwise -> aux := (*aux).left
                       fi
                 [] otherwise 
                    -> if (*aux).right == null 
                        -> new((*aux).right)
                         ; (*(*aux).right).element, i := x, t.tam-1
                       [] otherwise -> aux := (*aux).right
                       fi
                 fi
                ; i := i + 1
             od
       fi
     ; t.tam := t.tam + 1
    ]|
    
    proc printf (in t : BinaryTreeO(T))
    
      {pre true pre}
      {post true post}
      |[
        print(t.root, t.tam)
      ]|
    
  
end

main
    |[ var bt : BinaryTreeO(int)
     ; insert(bt, 1)
     ; insert(bt, -10)
     ; insert(bt, 10)
     ; insert(bt, -1210)
     ; insert(bt, 9)
     ; insert(bt, 123)
     // ; insert(bt, 10)
     // ; insert(bt, 10)
     ; printf(bt)
     ; writeln("Size: ",bt.tam)

     ; write(chao(1))
    ]|

end