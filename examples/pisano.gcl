//Pisano (Fibonacci and other stuff)

// abstract Diccionario (t0,t1) begin
//     var MAX   : int;
//     var conoc : set of t0;
//     var tabla : func t0 -> t1;

//     {inv MAX > 0 /\ 1 <=  MAX inv}

//     proc crear (out m : int)
//         {pre    0 <  m                pre}
//         {post MAX == m /\ conoc == m post}

// // No funcion
// /*    proc agregar (inout d : int, in c : int, in v : int)
//         {pre  !(c   == conoc)    /\ conoc <  MAX        pre}
//         {post conoc == conoc + 1 /\ tabla == tabla + c post}

//     proc eliminar (inout d : int, in c : int)
//         {pre  c     == conoc pre}
//         {post conoc == conoc - c /\ tabla == tabla - c post}

//     proc buscar (in d : int, in c: int, out v : int)
//         {pre  c == conoc  pre}
//         {post v == c     post}

//     proc existe (in d : int, in c : int, out e : boolean)
//         {pre  true       pre}
//         {post e == c > 2 post}*/
// end


type Dicc implements Diccionario (int,char)
begin

    var   MAX := 10 : int;
    var   tam       : int;
    var   clave     : array [1] of int;
    var   valor     : array [2] of int;

    {repinv MAX > 0 ∧ 0 ≤ tam ∧ tam ≤ MAX  //∧
        // (%forall i : int | 0 ≤ i /\ i ≤ 10 | i > 10%)
    repinv}

    {coupinv tam < MAX coupinv}

    proc crear (in m : int, out d : int)
    begin
        {pre    0 < m              pre}
        |[
            MAX, tam := m, 0
        ]|
        {post MAX == m /\ tam == 0  post}
    end

    // proc agregar (inout d : int , in c : int, in v : int)
    // begin
    //     var x      : int;
    //     var oldTam : int;
    //     {pre tam < MAX /\ !(%exist i : int | 0 <= i /\ i < tam | clave[i] == c %) pre}
    //     |[
    //         oldTam := tam;
    //         clave[tam], valor[tam], tam := c, v, tam + 1
    //     ]|
    //     {post tam == oldTam + 1 /\ (%exist i : int | 0 <= i /\ i < tam | clave[i] == c /\ valor[x] == v %) post}
    // end

    // proc eliminar (inout d : int, in c : int)
    // begin
    //     var x      : int;
    //     var oldTam : int;

    //     {pre (%exist i : int | 0 <= i /\ i < tam | clave[i] == c %)  pre}
    //     |[
    //         x := 4;
    //         oldTam := tam;
    //         {inv 0 <= x /\ x <= tam inv}

    //         {bound tam - x bound}
    //         do x < tam ->
    //             if clave[x] == x -> x, d, tam := x+1, d, tam-1
    //             [] clave[x] != x -> x := x+1
    //             fi
    //         od
    //     ]|
    //     {post tam == oldTam - 1  post}
    // end

    // proc buscar( in d : int, in c : int , out v : int )
    // begin
    //     var x : int;
    //     {pre (%exist i : int | 0 <= i /\ i < tam | clave[i] == c %) pre}
    //    |[
    //         x := 0;

    //         {inv 0 <= x /\ x <= tam inv}
    //         {bound tam - x bound}
    //         do clave[x] != c -> |[
    //             x := x + 1
    //         ]|
    //         od;

    //         v := valor[x]

    //     ]|
    //     {post (%exist i : int | 0 <= i /\ i < tam | c == clave[x] /\ v == valor[x] %) post}
    // end

    // proc existe (in d : int, in c : int, out e : boolean)
    // begin
    //     var x : int;
    //     {pre true pre}
    //     |[
    //         x := 0;
    //         e := false;

    //         {inv 0 <= x /\ x < tam inv}
    //         {bound tam - x bound}
    //         do x < tam /\ e == false ->
    //             if clave[x]  == c -> e := true
    //             [] clave[x] != c -> x := x + 1
    //             fi
    //         od
    //     ]|
    //     {post e == (%exist i : int | 0 <= i /\ i < tam | clave[i] == c%) post}
    // end
end


program main begin

    // func fibonacci (n : int, x : array [n] of int) -> int
    // begin
    //     if n == 0  -> 0
    //     [] n == 1  -> 1
    //     [] n >  1  -> 2 /*fibonacci(n-1) + fibonacci(n-2)*/ // Recursion
    //     fi
    // end

    // proc readNum ()
    // begin
    //     var num : int;
    //     read(num);
    //     var h : int;
    //     read(h);

    //     {pre num ≥ 0 pre}
    //     |[
    //         var i,j,k := 1,2,3 : int;
    //         // write("El resultado es: "); // No acepta strings
    //         {a i > 1 a}
    //         writeln(1) // No buscar las funciones
    //     ]|
    //     {post true post}
    // end

    proc readNum2 ()
    begin
        var num : int;
        read(num);

        {pre true pre}
        |[
            writeln("Entro! que alegria")
            // write("El resultado es: "); // No acepta strings
            // writeln(fibonacci(num)) // No buscar las funciones
        ]|
        {post true post}
    end

    proc hola (in x : int) begin
    
        {pre true pre}
        |[
            write(1)
        ]|
        {post true post}
    end
    

   |[ var a,b,d := -1.0,2.0,4.3 : float
    ; var g := a+b+d : float
    ; var i := 12  : int
    ; var x,y,z    : int*
    ; var dd       : int**
    ; var pedrito  : boolean*
    ; var c1,c2    : boolean
    ; var c := 'c' : char
    ; var arreglo  : array[10] of array[10] of array[10] of int*
    ; var bool     : boolean
    ; var dic      : Dicc of int    
    ; {a x == null a} new(x)  {a x != null a}
    ; *x := 1
    ; writeln(*x)
    ; {a x != null a} free(x) {a x == null a}
    ; read(i)
    ; writeln(2533,2533,"hola")
    ; write("x y z son iguales: ", x == z, "\n")
    ; new(arreglo[1][2][3])
    ; *arreglo[1][2][3] := 100
    ; new(x)
    ; new(pedrito)
    ; *pedrito := false
    ; free(pedrito)
    ; writeln(pedrito == null)
    ; new(dd)
    ; new(*dd)
    ; **dd := 3
    ; *x := i
    ; y := x
    ; z := y
    ; writeln(z != null /\ *z == i) // true
    ; writeln(*arreglo[1][2][3] + 2)
    ; |[
          writeln(12345);
          |[
              writeln(12)
          ]|
     ]|
    ; read(*x)
      
    ; 
    {a *x > 0 a}

    if *x > 10             -> a := 1.0      
    [] 0 <= *x /\ *x <= 10 -> a := 10.0
    fi
              
    {a    (*x > 10             ==> a == 1.0) 
       /\ (0 <= *x /\ *x <= 10 ==> a == 10.0)
    a}

    ; readNum2()

    ; writeln(a < 10.0)
    ; writeln(a > 10.0)
    ; writeln(a <= 10.0)
    ; writeln(a >= 10.0)
    ; writeln(a != 10.0)

    ; writeln(i < 10)
    ; writeln(i > 10)
    ; writeln(i <= 10)
    ; writeln(i >= 10)
    ; writeln(i != 10)

    ; writeln(false ==> true)
      
    ; writeln(i)
    //  ; read(a,b,c)

    ; writeln(g)
    ; writeln( ¬(true /\ false) )
    ; writeln(a)
    ; writeln(¬ (√(9.0+16.0) >= 5.0) )
    ; writeln( -2 == 2147483647 )
    ; new(x)
    ; *x := 20
    ; writeln(*x)
    ; *x := 10
    ; writeln(*x)
    ; *x := 15
    ; writeln(*x)
    ; free(x)
    ; new(x)
    ; *x,*x := 15, 10
    ; writeln(*x)
    ; writeln( (3 max 4) min (10 max √2) )
    ; free(x)  
   ]|
end
