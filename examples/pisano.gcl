//Pisano (Fibonacci and other stuff)

// abstract Diccionario (t0,t1) begin
//     var MAX   : int;
//     var conoc : set of t0;
//     var tabla : func t0 -> t1;

//     {inv MAX > 0 /\ 1 <=  MAX inv}

//     proc crear (out m : int)
//         {pre    0 <  m                pre}
//         {post MAX == m /\ conoc == m post}

// // No funcion
// /*    proc agregar (inout d : int, in c : int, in v : int)
//         {pre  !(c   == conoc)    /\ conoc <  MAX        pre}
//         {post conoc == conoc + 1 /\ tabla == tabla + c post}

//     proc eliminar (inout d : int, in c : int)
//         {pre  c     == conoc pre}
//         {post conoc == conoc - c /\ tabla == tabla - c post}

//     proc buscar (in d : int, in c: int, out v : int)
//         {pre  c == conoc  pre}
//         {post v == c     post}

//     proc existe (in d : int, in c : int, out e : boolean)
//         {pre  true       pre}
//         {post e == c > 2 post}*/
// end


// type Dicc implements Diccionario (int,char)
// begin

//     var   MAX := 10 : int;
//     var   tam       : int;
//     var   clave     : array [1] of int;
//     var   valor     : array [2] of int;

//     {repinv MAX > 0 ∧ // 0 ≤ tam ∧ tam ≤ MAX  ∧
//         (%forall i : int | 0 ≤ i /\ i ≤ tam
//           | (%forall j : int | 0 ≤ j /\ j ≤ tam // ∧ i ≢ j
//               | clave[i] != clave[j]
//             %)
//         %)
//     repinv}

//     {coupinv tam < MAX coupinv}

//     proc crear (in m : int, out d : int)
//     begin
//         {pre    0 < m              pre}
//         |[
//             MAX, tam := m, 0
//         ]|
//         {post MAX == m /\ tam ==0  post}
//     end

//     proc agregar (inout d : int , in c : int, in v : int)
//     begin
//         var x      : int;
//         var oldTam : int;
//         {pre tam < MAX /\ !(%exist i : int | 0 <= i /\ i < tam | clave[i] == c %) pre}
//         |[
//             oldTam := tam;
//             clave[tam], valor[tam], tam := c, v, tam + 1
//         ]|
//         {post tam == oldTam + 1 /\ (%exist i : int | 0 <= i /\ i < tam | clave[i] == c /\ valor[x] == v %) post}
//     end

//     proc eliminar (inout d : int, in c : int)
//     begin
//         var x      : int;
//         var oldTam : int;

//         {pre (%exist i : int | 0 <= i /\ i < tam | clave[i] == c %)  pre}
//         |[
//             x := 4;
//             oldTam := tam;
//             {inv 0 <= x /\ x <= tam inv}

//             {bound tam - x bound}
//             do x < tam ->
//                 if clave[x] == x -> x, d, tam := x+1, d, tam-1
//                 [] clave[x] != x -> x := x+1
//                 fi
//             od
//         ]|
//         {post tam == oldTam - 1  post}
//     end

//     proc buscar( in d : int, in c : int , out v : int )
//     begin
//         var x : int;
//         {pre (%exist i : int | 0 <= i /\ i < tam | clave[i] == c %) pre}
//        |[
//             x := 0;

//             {inv 0 <= x /\ x <= tam inv}
//             {bound tam - x bound}
//             do clave[x] != c -> |[
//                 x := x + 1
//             ]|
//             od;

//             v := valor[x]

//         ]|
//         {post (%exist i : int | 0 <= i /\ i < tam | c == clave[x] /\ v == valor[x] %) post}
//     end

//     proc existe (in d : int, in c : int, out e : boolean)
//     begin
//         var x : int;
//         {pre true pre}
//         |[
//             x := 0;
//             e := false;

//             {inv 0 <= x /\ x < tam inv}
//             {bound tam - x bound}
//             do x < tam /\ e == false ->
//                 if clave[x]  == c -> e := true
//                 [] clave[x] != c -> x := x + 1
//                 fi
//             od
//         ]|
//         {post e == (%exist i : int | 0 <= i /\ i < tam | clave[i] == c%) post}
//     end
// end


program main begin

    // func fibonacci (n : int, x : array [n] of int) -> int
    // begin
    //     if n == 0  -> 0
    //     [] n == 1  -> 1
    //     [] n >  1  -> 2 /*fibonacci(n-1) + fibonacci(n-2)*/ // Recursion
    //     fi
    // end

    // proc readNum ()
    // begin
    //     var num : int;
    //     read(num);

    //     {pre num ≥ 0 pre}
    //     |[
    //         var i,j,k := 1,2,3 : int;
    //         // write("El resultado es: "); // No acepta strings
    //         writeln(1) // No buscar las funciones
    //     ]|
    //     {post true post}
    // end

    // proc readNum2 ()
    // begin
    //     var num : int;
    //     read(num);

    //     {pre num ≥ 0 pre}
    //     |[
    //         write(1)
    //         // write("El resultado es: "); // No acepta strings
    //         // writeln(fibonacci(num)) // No buscar las funciones
    //     ]|
    //     {post true post}
    // end

    // proc hola (in x : int) begin
    
    //     {pre true pre}
    //     |[
    //         write(1)
    //     ]|
    //     {post true post}
    // end
    

    |[
        var a,b,c,d := -1.0,2.0,3.1,4.3 : float;
        var g := a+b+c+d : float;
        var i := 12  : int;
        var c := 'c' : char;
        var bool     : boolean;
        |[
            writeln(12345)
        ]|;
        read(a);
        if a > 1.0 -> 
            if a != 5.0 -> writeln(1.01234)
            [] true   -> writeln(1234.01)
            fi
        [] a < 1.0  -> writeln(2)
        fi;

        writeln(a < 10.0);
        writeln(a > 10.0);
        writeln(a <= 10.0);
        writeln(a >= 10.0);
        writeln(a != 10.0);

        writeln(i < 10);
        writeln(i > 10);
        writeln(i <= 10);
        writeln(i >= 10);
        writeln(i != 10);

        writeln(false ==> true);
        
        writeln(i);

        writeln(g);
        writeln(¬(true/\false));
        writeln(a);
        writeln(¬ (√(9.0+16.0) >= 5.0) );
        write( -2 + 2147483647 )

        // const   m := 10 : int;
        // var   a : array[10] of array[10] of int;

       

        // {inv (%forall i : int | i > 0 /\ i < 10 | true %)  inv}
        // {bound 1 bound}
        // do 
        //     true ->  
        //         if a[1][2] > 1 ->
        //              write(1) 
        //         fi
        // od;
        // |[  a[x] := x;
        //     {a a[x] < 10 /\ a[x] >= 0 a}
        //     writeln(a[x]);
        //     {a a[x] > 100 a}
        //     x := x+1
        //     {a x <= 10 a}
        // ]|
        // od;
        // random(m);
        
        // // write("El random es: "); // No acepta strings
        // writeln(1);
        // writeln(1-1-1);
        // // write("Numero de Fibonacci, ingrese un numero: "); // No acepta strings
        // x,m := 1,20;
        // readNum()
        //read(a[1][1])
    ]|
end
