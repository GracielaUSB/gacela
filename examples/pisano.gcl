//Pisano (Fibonacci and other stuff)
program Hola.bin begin

  abstract Diccionario (t0,t1) begin
    var MAX   : t0;
    var conoc : set of t0;
    var tabla : func t0 -> t1;

    {inv 1 > 0 inv}

    proc crear (out d : Diccionario, in m : int)
      {pre  0 <  m  pre}
      {post 1 == m post}


    proc agregar (in d : Diccionario, in c : t0, in v : t1)
      {pre  true pre}
      {post true post}
  end

  type Dicc (a,b) implements Diccionario (a,b) begin
    var   tam   : int;
    var   clave : array [1] of int;
    var   valor : array [2] of int;

    {repinv 0  <= 100 repinv}

    {coupinv false coupinv}
    
    proc crear (out d : Dicc, in m : int)
      {pre  1 == 0 pre}
      {post 1 == 0 \/ 1 != 0 post}
      |[
        write(1)
      ]|
      

    proc agregar (in d : Dicc, in c : a, in v : b)

      var x       : int;
      var tam'    : int;

      var tam, MAX  : int;
      var clave     : array [1] of int;
      var valor     : array [2] of int;

      {pre  tam < MAX /*\/ !(%exist i : int | 0 <= i ∧ i < tam | clave[i] == c %)*/ pre}
      {post tam == tam' + 1 /*∧ (%exist i : int | 0 <= i ∧ i < tam | clave[i] == c ∧ valor[x] == v %) */post}
      
      |[
        tam' := tam;
        clave[tam], valor[tam], tam := 2, 3, tam + 1
      ]|
      
  end
  func fibo (i : int) -> int
    {pre i >= 0 pre}
    {post i > 0 post}
    {bound i bound}
    |[
      1

    ]|
    // hols

  func fibonacci (n : int*, x : array [10] of int) -> boolean
    {pre true pre}
    {post true post}
    |[
      if if if if true -> true fi -> true fi -> true fi -> true fi
    ]|

  // proc readNum ()
  //     var num : int;
  //     read(num);
  //     var h : int;
  //     read(h);

  //     {pre num ≥ 0 pre}
  //     {post true post}
  //     |[
  //         var i,j,k := 1,2,3 : int;
  //         // write("El resultado es: "); // No acepta strings
  //         { i > 1 }
  //         writeln(1) // No buscar las funciones
  //     ]|
      

  // proc readNum2 (out i : int*)
  //     {pre true pre}
  //     {post true post}
  //     {bound 1 bound}
  //     |[
  //         free(i);
  //         if i != null -> 
  //                       writeln("No es null asi que la nulifico y entro recursivamente")
  //                       ; readNum2(i)
  //         [] i == null -> writeln("Es null, termino la recursion")
  //         fi
  //     ]|
      

  // proc hola2 (out i : int, in t : array[10] of int)
  //   {pre true pre}
  //   {post true post}
  //   {bound 1 bound}
  //   |[
  //     i := 10;
  //     |[
  //       var i := 100: int;
  //       if i > 1 ->
  //         var i := 1000 + t[1] : int;

  //         writeln(i, "hola")
  //       fi;
  //       writeln(i)
  //     ]|;
  //     writeln(i);

  //     // hola2(i,t)
  //   ]|

  
  // proc hola (inout x : int)

  //   {pre x == 0 pre}
  //   {post x == 11 post}
  //   |[
  //       read(x)

  //       // { x >= 10 }

  //       // ; x := 10
  //   ]|
    
  
  main
  |[ 
      var a,b,d := 1.0,2.0,3.0 : float
    ; var g := a+b+d : float
    ; var i := 12  : int
    ; var x,y,z    : int*
    ; var dd       : int**
    ; var pedrito  : boolean*
    ; var c1,c2    : boolean
    ; var c := 'c' : char
    ; var arreglo  : array[10] of array[10] of array[10] of int*
    ; var bool     : boolean   
    ; { x == null } new(x)  { x != null }
    ; *x := 1
    ; writeln(*x)
    ; { x != null } free(x) { x == null }
    ; read(i)
    ; writeln(2533,2533,"hola")
    ; write("x y z son iguales: ", x == z, "\n")
    ; new(arreglo[1][2][3])
    ; *arreglo[1][2][3] := 100
    ; new(x)
    ; new(pedrito)
    ; *pedrito := false
    ; free(pedrito)
    ; writeln(pedrito == null)
    ; new(dd)
    ; new(*dd)
    ; **dd := 3
    ; *x := i
    ; y := x
    ; z := y
    ; writeln(z != null /\ *z == i) // true
    ; writeln(*arreglo[1][2][3] + 2)
    ; |[
          writeln(12345);
          |[
              writeln(12)
          ]|
     ]|
    ; read(*x)
      
    ; 
    { *x > 0 }

    if *x > 10             -> a := 1.0      
    [] 0 <= *x /\ *x <= 10 -> a := 10.0
    fi
              
    {    (*x > 10             ==> a == 1.0) 
       /\ (0 <= *x /\ *x <= 10 ==> a == 10.0)
    }


    ; writeln(a < 10.0)
    ; writeln(a > 10.0)
    ; writeln(a <= 10.0)
    ; writeln(a >= 10.0)
    ; writeln(a != 10.0)

    ; writeln(i < 10)
    ; writeln(i > 10)
    ; writeln(i <= 10)
    ; writeln(i >= 10)
    ; writeln(i != 10)

    ; writeln(false ==> true)
      
    ; writeln(i)
    //  ; read(a,b,c)

    ; writeln(g)
    ; writeln( ¬(true /\ false) )
    ; writeln(a)
    ; writeln(¬ (√(9.0+16.0) >= 5.0) )
    ; writeln( -2 == 2147483647 )
    ; new(x)
    ; *x := 20
    ; writeln(*x)
    ; *x := 10
    ; writeln(*x)
    ; *x := 15
    ; writeln(*x)
    ; free(x)
    ; new(x)
    ; *x,*x := 15, 10
    ; writeln(*x)
    ; writeln( (3 max 4) min (10 max √2) )
    ; free(x)  
    ; new(x)
    ; writeln( x != null )
    ; writeln( x == null )

  ]|
end
