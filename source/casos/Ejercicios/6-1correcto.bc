; ModuleID = 'main'

@0 = constant [18 x i16] [i16 69, i16 108, i16 32, i16 114, i16 101, i16 115, i16 117, i16 108, i16 116, i16 97, i16 100, i16 111, i16 32, i16 101, i16 115, i16 58, i16 32, i16 0]

declare i32 @_random()

declare void @_abort(i32, i32, i32)

declare void @_writeLnInt(i32)

declare void @_writeInt(i32)

declare i32 @_min(i32, i32)

declare i32 @_max(i32, i32)

declare void @_writeLnChar(i9)

declare void @_writeChar(i9)

declare void @_writeLnBool(i1)

declare void @_writeBool(i1)

declare void @_writeLnDouble(double)

declare void @_writeDouble(double)

; Function Attrs: nounwind readonly
declare double @llvm.sqrt.f64(double) #0

; Function Attrs: nounwind readonly
declare double @llvm.fabs.f64(double) #0

declare double @_minF(double, double)

declare double @_maxF(double, double)

; Function Attrs: nounwind readonly
declare double @llvm.pow.f64(double, double) #0

declare i32 @_writeLnString(i16* nocapture)

declare i32 @_writeString(i16* nocapture)

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.sadd.with.overflow.i32(i32, i32) #1

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.ssub.with.overflow.i32(i32, i32) #1

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.smul.with.overflow.i32(i32, i32) #1

declare i32 @_readIntStd()

declare i9 @_readCharStd()

declare double @_readDoubleStd()

declare i8* @_openFile(i8*)

declare i32 @_readFileInt(i8*)

declare i9 @_readFileChar(i8*)

declare double @_readFileDouble(i8*)

declare void @_closeFile(i8*)

define void @buscar(i1* %b, i32* %x) {
  %_x = alloca i32
  store i32 0, i32* %_x
  %k = alloca i32
  store i32 50, i32* %k
  %i = alloca i32
  store i32 0, i32* %i
  %"8" = alloca i1
  store i1 true, i1* %"8"
  br label %1

; <label>:1                                       ; preds = %6, %0
  %2 = load i32* %i
  %3 = icmp sle i32 %2, 10
  %4 = load i1* %"8"
  %5 = and i1 %3, %4
  br i1 %5, label %6, label %8

; <label>:6                                       ; preds = %1
  %7 = add i32 %2, 1
  store i32 %7, i32* %i
  store i1 false, i1* %"8"
  br label %1

; <label>:8                                       ; preds = %1
  %9 = load i1* %"8"
  %10 = xor i1 %9, true
  br i1 %10, label %12, label %11

; <label>:11                                      ; preds = %8
  call void @_abort(i32 11, i32 10, i32 14)
  br label %12

; <label>:12                                      ; preds = %11, %8
  %_resPrebuscar = alloca i1
  store i1 %10, i1* %_resPrebuscar
  br i1 %10, label %14, label %13

; <label>:13                                      ; preds = %12
  call void @_abort(i32 3, i32 11, i32 9)
  br label %14

; <label>:14                                      ; preds = %13, %12
  store i32 0, i32* %_x
  %"37" = alloca i32
  store i32 2147483647, i32* %"37"
  br label %15

; <label>:15                                      ; preds = %40, %14
  br i1 true, label %17, label %16

; <label>:16                                      ; preds = %15
  call void @_abort(i32 6, i32 15, i32 13)
  br label %17

; <label>:17                                      ; preds = %16, %15
  %18 = load i32* %k
  %19 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %18, i32 1)
  %20 = extractvalue { i32, i1 } %19, 1
  br i1 %20, label %21, label %22

; <label>:21                                      ; preds = %17
  call void @_abort(i32 12, i32 15, i32 21)
  unreachable

; <label>:22                                      ; preds = %17
  %23 = extractvalue { i32, i1 } %19, 0
  %24 = load i32* %"37"
  %25 = icmp slt i32 %23, %24
  br i1 %25, label %26, label %28

; <label>:26                                      ; preds = %22
  %27 = icmp sle i32 %23, 0
  store i32 %23, i32* %"37"
  br i1 %27, label %29, label %30

; <label>:28                                      ; preds = %22
  call void @_abort(i32 7, i32 17, i32 13)
  unreachable

; <label>:29                                      ; preds = %26
  call void @_abort(i32 8, i32 17, i32 13)
  unreachable

; <label>:30                                      ; preds = %26
  %31 = load i32* %_x
  %32 = getelementptr inbounds i1* %b, i32 %31
  %33 = load i1* %32
  %34 = xor i1 %33, true
  br i1 %34, label %35, label %42

; <label>:35                                      ; preds = %30
  %36 = load i32* %_x
  %37 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %36, i32 1)
  %38 = extractvalue { i32, i1 } %37, 1
  br i1 %38, label %39, label %40

; <label>:39                                      ; preds = %35
  call void @_abort(i32 12, i32 17, i32 33)
  unreachable

; <label>:40                                      ; preds = %35
  %41 = extractvalue { i32, i1 } %37, 0
  store i32 %41, i32* %_x
  br label %15

; <label>:42                                      ; preds = %30
  %43 = load i32* %_x
  store i32 %43, i32* %x
  %44 = load i1* %_resPrebuscar
  %45 = xor i1 %44, true
  %46 = or i1 %45, true
  br i1 %46, label %48, label %47

; <label>:47                                      ; preds = %42
  call void @_abort(i32 4, i32 21, i32 5)
  br label %48

; <label>:48                                      ; preds = %47, %42
  ret void
}

define void @main() {
  %arreglo = alloca i1, i32 50
  %resultado = alloca i32
  store i32 0, i32* %resultado
  call void @buscar(i1* %arreglo, i32* %resultado)
  %1 = call i32 @_writeString(i16* getelementptr inbounds ([18 x i16]* @0, i64 0, i64 0))
  %2 = load i32* %resultado
  call void @_writeLnInt(i32 %2)
  ret void
}

attributes #0 = { nounwind readonly }
attributes #1 = { nounwind readnone }
