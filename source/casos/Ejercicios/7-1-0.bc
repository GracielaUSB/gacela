; ModuleID = 'main'

@0 = constant [18 x i16] [i16 69, i16 108, i16 32, i16 114, i16 101, i16 115, i16 117, i16 108, i16 116, i16 97, i16 100, i16 111, i16 32, i16 101, i16 115, i16 58, i16 32, i16 0]

declare i32 @_random()

declare void @_abort(i32, i32, i32)

declare void @_writeLnInt(i32)

declare void @_writeInt(i32)

declare i32 @_min(i32, i32)

declare i32 @_max(i32, i32)

declare void @_writeLnChar(i9)

declare void @_writeChar(i9)

declare void @_writeLnBool(i1)

declare void @_writeBool(i1)

declare void @_writeLnDouble(double)

declare void @_writeDouble(double)

; Function Attrs: nounwind readonly
declare double @llvm.sqrt.f64(double) #0

; Function Attrs: nounwind readonly
declare double @llvm.fabs.f64(double) #0

declare double @_minF(double, double)

declare double @_maxF(double, double)

; Function Attrs: nounwind readonly
declare double @llvm.pow.f64(double, double) #0

declare i32 @_writeLnString(i16* nocapture)

declare i32 @_writeString(i16* nocapture)

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.sadd.with.overflow.i32(i32, i32) #1

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.ssub.with.overflow.i32(i32, i32) #1

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.smul.with.overflow.i32(i32, i32) #1

declare i32 @_readIntStd()

declare i9 @_readCharStd()

declare double @_readDoubleStd()

declare i8* @_openFile(i8*)

declare i32 @_readFileInt(i8*)

declare i9 @_readFileChar(i8*)

declare double @_readFileDouble(i8*)

declare void @_closeFile(i8*)

define void @TodosCeros(i32 %N, i32* %X, i32* %res) {
  %_N = alloca i32
  store i32 %N, i32* %_N
  %_res = alloca i32
  store i32 0, i32* %_res
  %n = alloca i32
  store i32 0, i32* %n
  %s = alloca i32
  store i32 0, i32* %s
  %cota = alloca i32
  store i32 0, i32* %cota
  %1 = load i32* %_N
  %2 = icmp sgt i32 %1, 0
  %_resPreTodosCeros = alloca i1
  store i1 %2, i1* %_resPreTodosCeros
  br i1 %2, label %4, label %3

; <label>:3                                       ; preds = %0
  call void @_abort(i32 3, i32 12, i32 9)
  br label %4

; <label>:4                                       ; preds = %3, %0
  %__n = alloca i32
  store i32 0, i32* %__n
  %__res = alloca i32
  store i32 0, i32* %__res
  %__s = alloca i32
  store i32 0, i32* %__s
  %__cota = alloca i32
  store i32 5000, i32* %__cota
  %5 = load i32* %__n
  store i32 %5, i32* %n
  %6 = load i32* %__res
  store i32 %6, i32* %_res
  %7 = load i32* %__s
  store i32 %7, i32* %s
  %8 = load i32* %__cota
  store i32 %8, i32* %cota
  %"29" = alloca i32
  store i32 2147483647, i32* %"29"
  br label %9

; <label>:9                                       ; preds = %70, %4
  br i1 true, label %11, label %10

; <label>:10                                      ; preds = %9
  call void @_abort(i32 6, i32 16, i32 21)
  br label %11

; <label>:11                                      ; preds = %10, %9
  %12 = load i32* %cota
  %13 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %12, i32 1)
  %14 = extractvalue { i32, i1 } %13, 1
  br i1 %14, label %15, label %16

; <label>:15                                      ; preds = %11
  call void @_abort(i32 12, i32 16, i32 32)
  unreachable

; <label>:16                                      ; preds = %11
  %17 = extractvalue { i32, i1 } %13, 0
  %18 = load i32* %"29"
  %19 = icmp slt i32 %17, %18
  br i1 %19, label %20, label %22

; <label>:20                                      ; preds = %16
  %21 = icmp sle i32 %17, 0
  store i32 %17, i32* %"29"
  br i1 %21, label %23, label %24

; <label>:22                                      ; preds = %16
  call void @_abort(i32 7, i32 18, i32 13)
  unreachable

; <label>:23                                      ; preds = %20
  call void @_abort(i32 8, i32 18, i32 13)
  unreachable

; <label>:24                                      ; preds = %20
  %25 = load i32* %n
  %26 = load i32* %_N
  %27 = icmp ne i32 %25, %26
  br i1 %27, label %28, label %74

; <label>:28                                      ; preds = %24
  %29 = load i32* %n
  %30 = getelementptr inbounds i32* %X, i32 %29
  %31 = load i32* %30
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %34

; <label>:33                                      ; preds = %28
  br label %47

; <label>:34                                      ; preds = %28
  %35 = load i32* %n
  %36 = getelementptr inbounds i32* %X, i32 %35
  %37 = load i32* %36
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %39, label %46

; <label>:39                                      ; preds = %34
  %40 = load i32* %n
  %41 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %40, i32 1)
  %42 = extractvalue { i32, i1 } %41, 1
  br i1 %42, label %43, label %44

; <label>:43                                      ; preds = %39
  call void @_abort(i32 12, i32 22, i32 41)
  unreachable

; <label>:44                                      ; preds = %39
  %45 = extractvalue { i32, i1 } %41, 0
  store i32 %45, i32* %s
  br label %47

; <label>:46                                      ; preds = %34
  call void @_abort(i32 1, i32 21, i32 17)
  unreachable

; <label>:47                                      ; preds = %44, %33
  %48 = load i32* %n
  %49 = load i32* %s
  %50 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 1, i32 %49)
  %51 = extractvalue { i32, i1 } %50, 1
  br i1 %51, label %52, label %53

; <label>:52                                      ; preds = %47
  call void @_abort(i32 12, i32 25, i32 35)
  unreachable

; <label>:53                                      ; preds = %47
  %54 = extractvalue { i32, i1 } %50, 0
  %55 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %48, i32 %54)
  %56 = extractvalue { i32, i1 } %55, 1
  br i1 %56, label %57, label %58

; <label>:57                                      ; preds = %53
  call void @_abort(i32 12, i32 25, i32 33)
  unreachable

; <label>:58                                      ; preds = %53
  %59 = extractvalue { i32, i1 } %55, 0
  store i32 %59, i32* %_res
  %60 = load i32* %n
  %61 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %60, i32 1)
  %62 = extractvalue { i32, i1 } %61, 1
  br i1 %62, label %63, label %64

; <label>:63                                      ; preds = %58
  call void @_abort(i32 12, i32 26, i32 37)
  unreachable

; <label>:64                                      ; preds = %58
  %65 = extractvalue { i32, i1 } %61, 0
  store i32 %65, i32* %__n
  %66 = load i32* %cota
  %67 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %66, i32 1)
  %68 = extractvalue { i32, i1 } %67, 1
  br i1 %68, label %69, label %70

; <label>:69                                      ; preds = %64
  call void @_abort(i32 12, i32 26, i32 45)
  unreachable

; <label>:70                                      ; preds = %64
  %71 = extractvalue { i32, i1 } %67, 0
  store i32 %71, i32* %__cota
  %72 = load i32* %__n
  store i32 %72, i32* %n
  %73 = load i32* %__cota
  store i32 %73, i32* %cota
  br label %9

; <label>:74                                      ; preds = %24
  %75 = load i32* %_res
  store i32 %75, i32* %res
  %76 = load i1* %_resPreTodosCeros
  %77 = xor i1 %76, true
  %78 = or i1 %77, true
  br i1 %78, label %80, label %79

; <label>:79                                      ; preds = %74
  call void @_abort(i32 4, i32 31, i32 5)
  br label %80

; <label>:80                                      ; preds = %79, %74
  ret void
}

define void @main() {
  %arr = alloca i32, i32 10
  %resultado = alloca i32
  store i32 0, i32* %resultado
  %1 = getelementptr inbounds i32* %arr, i32 0
  store i32 0, i32* %1
  %2 = getelementptr inbounds i32* %arr, i32 1
  store i32 0, i32* %2
  %3 = getelementptr inbounds i32* %arr, i32 2
  store i32 6, i32* %3
  %4 = getelementptr inbounds i32* %arr, i32 3
  store i32 5, i32* %4
  %5 = getelementptr inbounds i32* %arr, i32 4
  store i32 -8, i32* %5
  %6 = getelementptr inbounds i32* %arr, i32 5
  store i32 5, i32* %6
  %7 = getelementptr inbounds i32* %arr, i32 6
  store i32 5, i32* %7
  %8 = getelementptr inbounds i32* %arr, i32 7
  store i32 1, i32* %8
  %9 = getelementptr inbounds i32* %arr, i32 8
  store i32 8, i32* %9
  %10 = getelementptr inbounds i32* %arr, i32 9
  store i32 -2, i32* %10
  call void @TodosCeros(i32 10, i32* %arr, i32* %resultado)
  %11 = call i32 @_writeString(i16* getelementptr inbounds ([18 x i16]* @0, i64 0, i64 0))
  %12 = load i32* %resultado
  call void @_writeLnInt(i32 %12)
  ret void
}

attributes #0 = { nounwind readonly }
attributes #1 = { nounwind readnone }
