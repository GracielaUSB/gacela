; ModuleID = 'main'

@0 = constant [36 x i16] [i16 69, i16 115, i16 99, i16 114, i16 105, i16 98, i16 97, i16 32, i16 101, i16 108, i16 32, i16 100, i16 105, i16 118, i16 105, i16 100, i16 101, i16 110, i16 100, i16 111, i16 32, i16 121, i16 32, i16 101, i16 108, i16 32, i16 100, i16 105, i16 118, i16 105, i16 115, i16 111, i16 114, i16 58, i16 32, i16 0]
@1 = constant [18 x i16] [i16 69, i16 108, i16 32, i16 114, i16 101, i16 115, i16 117, i16 108, i16 116, i16 97, i16 100, i16 111, i16 32, i16 101, i16 115, i16 58, i16 32, i16 0]
@2 = constant [14 x i16] [i16 69, i16 108, i16 32, i16 114, i16 101, i16 115, i16 116, i16 111, i16 32, i16 101, i16 115, i16 58, i16 32, i16 0]

declare i32 @_random()

declare void @_abort(i32, i32, i32)

declare void @_writeLnInt(i32)

declare void @_writeInt(i32)

declare i32 @_min(i32, i32)

declare i32 @_max(i32, i32)

declare void @_writeLnChar(i9)

declare void @_writeChar(i9)

declare void @_writeLnBool(i1)

declare void @_writeBool(i1)

declare void @_writeLnDouble(double)

declare void @_writeDouble(double)

; Function Attrs: nounwind readonly
declare double @llvm.sqrt.f64(double) #0

; Function Attrs: nounwind readonly
declare double @llvm.fabs.f64(double) #0

declare double @_minF(double, double)

declare double @_maxF(double, double)

; Function Attrs: nounwind readonly
declare double @llvm.pow.f64(double, double) #0

declare i32 @_writeLnString(i16* nocapture)

declare i32 @_writeString(i16* nocapture)

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.sadd.with.overflow.i32(i32, i32) #1

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.ssub.with.overflow.i32(i32, i32) #1

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.smul.with.overflow.i32(i32, i32) #1

declare i32 @_readIntStd()

declare i9 @_readCharStd()

declare double @_readDoubleStd()

declare i8* @_openFile(i8*)

declare i32 @_readFileInt(i8*)

declare i9 @_readFileChar(i8*)

declare double @_readFileDouble(i8*)

declare void @_closeFile(i8*)

define void @dividir(i32* %q, i32* %r) {
  %_q = alloca i32
  store i32 0, i32* %_q
  %_r = alloca i32
  store i32 0, i32* %_r
  %A = alloca i32
  store i32 0, i32* %A
  %B = alloca i32
  store i32 0, i32* %B
  %b = alloca i32
  store i32 0, i32* %b
  %i = alloca i32
  store i32 0, i32* %i
  %f = alloca double
  store double 0.000000e+00, double* %f
  %1 = call i32 @_readIntStd()
  %2 = call i32 @_readIntStd()
  store i32 %1, i32* %A
  store i32 %2, i32* %B
  %3 = load i32* %A
  %4 = icmp sge i32 %3, 0
  %5 = load i32* %B
  %6 = icmp sge i32 %5, 0
  %7 = and i1 %4, %6
  %_resPredividir = alloca i1
  store i1 %7, i1* %_resPredividir
  br i1 %7, label %9, label %8

; <label>:8                                       ; preds = %0
  call void @_abort(i32 3, i32 15, i32 9)
  br label %9

; <label>:9                                       ; preds = %8, %0
  %__q = alloca i32
  store i32 0, i32* %__q
  %10 = load i32* %A
  %__r = alloca i32
  store i32 %10, i32* %__r
  %11 = load i32* %B
  %__b = alloca i32
  store i32 %11, i32* %__b
  %12 = load i32* %A
  %__i = alloca i32
  store i32 %12, i32* %__i
  %13 = load i32* %__q
  store i32 %13, i32* %_q
  %14 = load i32* %__r
  store i32 %14, i32* %_r
  %15 = load i32* %__b
  store i32 %15, i32* %b
  %16 = load i32* %__i
  store i32 %16, i32* %i
  %"41" = alloca i32
  store i32 2147483647, i32* %"41"
  br label %17

; <label>:17                                      ; preds = %47, %9
  br i1 true, label %19, label %18

; <label>:18                                      ; preds = %17
  call void @_abort(i32 6, i32 19, i32 13)
  br label %19

; <label>:19                                      ; preds = %18, %17
  %20 = load i32* %i
  %21 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %20, i32 1)
  %22 = extractvalue { i32, i1 } %21, 1
  br i1 %22, label %23, label %24

; <label>:23                                      ; preds = %19
  call void @_abort(i32 12, i32 19, i32 21)
  unreachable

; <label>:24                                      ; preds = %19
  %25 = extractvalue { i32, i1 } %21, 0
  %26 = load i32* %"41"
  %27 = icmp slt i32 %25, %26
  br i1 %27, label %28, label %30

; <label>:28                                      ; preds = %24
  %29 = icmp sle i32 %25, 0
  store i32 %25, i32* %"41"
  br i1 %29, label %31, label %32

; <label>:30                                      ; preds = %24
  call void @_abort(i32 7, i32 20, i32 13)
  unreachable

; <label>:31                                      ; preds = %28
  call void @_abort(i32 8, i32 20, i32 13)
  unreachable

; <label>:32                                      ; preds = %28
  %33 = load i32* %_r
  %34 = load i32* %b
  %35 = icmp sge i32 %33, %34
  br i1 %35, label %36, label %51

; <label>:36                                      ; preds = %32
  %37 = load i32* %b
  %38 = call { i32, i1 } @llvm.smul.with.overflow.i32(i32 %37, i32 2)
  %39 = extractvalue { i32, i1 } %38, 1
  br i1 %39, label %40, label %41

; <label>:40                                      ; preds = %36
  call void @_abort(i32 12, i32 20, i32 36)
  unreachable

; <label>:41                                      ; preds = %36
  %42 = extractvalue { i32, i1 } %38, 0
  store i32 %42, i32* %__b
  %43 = load i32* %i
  %44 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %43, i32 1)
  %45 = extractvalue { i32, i1 } %44, 1
  br i1 %45, label %46, label %47

; <label>:46                                      ; preds = %41
  call void @_abort(i32 12, i32 20, i32 41)
  unreachable

; <label>:47                                      ; preds = %41
  %48 = extractvalue { i32, i1 } %44, 0
  store i32 %48, i32* %__i
  %49 = load i32* %__b
  store i32 %49, i32* %b
  %50 = load i32* %__i
  store i32 %50, i32* %i
  br label %17

; <label>:51                                      ; preds = %32
  %"104" = alloca i32
  store i32 2147483647, i32* %"104"
  br label %52

; <label>:52                                      ; preds = %109, %51
  br i1 true, label %54, label %53

; <label>:53                                      ; preds = %52
  call void @_abort(i32 6, i32 23, i32 13)
  br label %54

; <label>:54                                      ; preds = %53, %52
  %55 = load i32* %b
  %56 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %55, i32 1)
  %57 = extractvalue { i32, i1 } %56, 1
  br i1 %57, label %58, label %59

; <label>:58                                      ; preds = %54
  call void @_abort(i32 12, i32 23, i32 21)
  unreachable

; <label>:59                                      ; preds = %54
  %60 = extractvalue { i32, i1 } %56, 0
  %61 = load i32* %"104"
  %62 = icmp slt i32 %60, %61
  br i1 %62, label %63, label %65

; <label>:63                                      ; preds = %59
  %64 = icmp sle i32 %60, 0
  store i32 %60, i32* %"104"
  br i1 %64, label %66, label %67

; <label>:65                                      ; preds = %59
  call void @_abort(i32 7, i32 25, i32 13)
  unreachable

; <label>:66                                      ; preds = %63
  call void @_abort(i32 8, i32 25, i32 13)
  unreachable

; <label>:67                                      ; preds = %63
  %68 = load i32* %b
  %69 = load i32* %B
  %70 = icmp ne i32 %68, %69
  br i1 %70, label %71, label %110

; <label>:71                                      ; preds = %67
  %72 = load i32* %_q
  %73 = call { i32, i1 } @llvm.smul.with.overflow.i32(i32 %72, i32 2)
  %74 = extractvalue { i32, i1 } %73, 1
  br i1 %74, label %75, label %76

; <label>:75                                      ; preds = %71
  call void @_abort(i32 12, i32 27, i32 26)
  unreachable

; <label>:76                                      ; preds = %71
  %77 = extractvalue { i32, i1 } %73, 0
  store i32 %77, i32* %__q
  %78 = load i32* %b
  br i1 false, label %79, label %80

; <label>:79                                      ; preds = %76
  call void @_abort(i32 9, i32 27, i32 31)
  unreachable

; <label>:80                                      ; preds = %76
  %81 = sdiv exact i32 %78, 2
  store i32 %81, i32* %__b
  %82 = load i32* %__q
  store i32 %82, i32* %_q
  %83 = load i32* %__b
  store i32 %83, i32* %b
  %84 = load i32* %_r
  %85 = load i32* %b
  %86 = icmp slt i32 %84, %85
  br i1 %86, label %87, label %88

; <label>:87                                      ; preds = %80
  br label %109

; <label>:88                                      ; preds = %80
  %89 = load i32* %_r
  %90 = load i32* %b
  %91 = icmp sge i32 %89, %90
  br i1 %91, label %92, label %108

; <label>:92                                      ; preds = %88
  %93 = load i32* %_q
  %94 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %93, i32 1)
  %95 = extractvalue { i32, i1 } %94, 1
  br i1 %95, label %96, label %97

; <label>:96                                      ; preds = %92
  call void @_abort(i32 12, i32 30, i32 41)
  unreachable

; <label>:97                                      ; preds = %92
  %98 = extractvalue { i32, i1 } %94, 0
  store i32 %98, i32* %__q
  %99 = load i32* %_r
  %100 = load i32* %b
  %101 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %99, i32 %100)
  %102 = extractvalue { i32, i1 } %101, 1
  br i1 %102, label %103, label %104

; <label>:103                                     ; preds = %97
  call void @_abort(i32 12, i32 30, i32 46)
  unreachable

; <label>:104                                     ; preds = %97
  %105 = extractvalue { i32, i1 } %101, 0
  store i32 %105, i32* %__r
  %106 = load i32* %__q
  store i32 %106, i32* %_q
  %107 = load i32* %__r
  store i32 %107, i32* %_r
  br label %109

; <label>:108                                     ; preds = %88
  call void @_abort(i32 1, i32 29, i32 17)
  unreachable

; <label>:109                                     ; preds = %104, %87
  br label %52

; <label>:110                                     ; preds = %67
  %111 = load i32* %_r
  store i32 %111, i32* %r
  %112 = load i32* %_q
  store i32 %112, i32* %q
  %113 = load i32* %_q
  %114 = load i32* %A
  %115 = load i32* %B
  %116 = icmp eq i32 %115, 0
  br i1 %116, label %117, label %118

; <label>:117                                     ; preds = %110
  call void @_abort(i32 9, i32 36, i32 21)
  unreachable

; <label>:118                                     ; preds = %110
  %119 = sdiv exact i32 %114, %115
  %120 = icmp eq i32 %113, %119
  %121 = load i32* %_r
  %122 = load i32* %A
  %123 = load i32* %B
  %124 = icmp eq i32 %123, 0
  br i1 %124, label %125, label %126

; <label>:125                                     ; preds = %118
  call void @_abort(i32 9, i32 36, i32 34)
  unreachable

; <label>:126                                     ; preds = %118
  %127 = urem i32 %122, %123
  %128 = icmp eq i32 %121, %127
  %129 = and i1 %120, %128
  %130 = load i1* %_resPredividir
  %131 = xor i1 %130, true
  %132 = or i1 %131, %129
  br i1 %132, label %134, label %133

; <label>:133                                     ; preds = %126
  call void @_abort(i32 4, i32 37, i32 5)
  br label %134

; <label>:134                                     ; preds = %133, %126
  ret void
}

define void @main() {
  %resultado = alloca i32
  store i32 0, i32* %resultado
  %resto = alloca i32
  store i32 0, i32* %resto
  %1 = call i32 @_writeString(i16* getelementptr inbounds ([36 x i16]* @0, i64 0, i64 0))
  call void @dividir(i32* %resultado, i32* %resto)
  %2 = call i32 @_writeString(i16* getelementptr inbounds ([18 x i16]* @1, i64 0, i64 0))
  %3 = load i32* %resultado
  call void @_writeLnInt(i32 %3)
  %4 = call i32 @_writeString(i16* getelementptr inbounds ([14 x i16]* @2, i64 0, i64 0))
  %5 = load i32* %resto
  call void @_writeLnInt(i32 %5)
  ret void
}

attributes #0 = { nounwind readonly }
attributes #1 = { nounwind readnone }
