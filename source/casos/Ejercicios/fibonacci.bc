; ModuleID = 'main'

@0 = constant [20 x i16] [i16 92, i16 110, i16 69, i16 108, i16 32, i16 114, i16 101, i16 115, i16 117, i16 108, i16 116, i16 97, i16 100, i16 111, i16 32, i16 101, i16 115, i16 58, i16 32, i16 0]
@1 = constant [41 x i16] [i16 78, i16 117, i16 109, i16 101, i16 114, i16 111, i16 32, i16 100, i16 101, i16 32, i16 70, i16 105, i16 98, i16 111, i16 110, i16 97, i16 99, i16 99, i16 105, i16 44, i16 32, i16 105, i16 110, i16 103, i16 114, i16 101, i16 115, i16 101, i16 32, i16 117, i16 110, i16 32, i16 110, i16 117, i16 109, i16 101, i16 114, i16 111, i16 58, i16 32, i16 0]

declare i32 @_random()

declare void @_abort(i32, i32, i32)

declare void @_writeLnInt(i32)

declare void @_writeInt(i32)

declare i32 @_min(i32, i32)

declare i32 @_max(i32, i32)

declare void @_writeLnChar(i9)

declare void @_writeChar(i9)

declare void @_writeLnBool(i1)

declare void @_writeBool(i1)

declare void @_writeLnDouble(double)

declare void @_writeDouble(double)

; Function Attrs: nounwind readonly
declare double @llvm.sqrt.f64(double) #0

; Function Attrs: nounwind readonly
declare double @llvm.fabs.f64(double) #0

declare double @_minF(double, double)

declare double @_maxF(double, double)

; Function Attrs: nounwind readonly
declare double @llvm.pow.f64(double, double) #0

declare i32 @_writeLnString(i16* nocapture)

declare i32 @_writeString(i16* nocapture)

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.sadd.with.overflow.i32(i32, i32) #1

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.ssub.with.overflow.i32(i32, i32) #1

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.smul.with.overflow.i32(i32, i32) #1

declare i32 @_readIntStd()

declare i9 @_readCharStd()

declare double @_readDoubleStd()

declare i8* @_openFile(i8*)

declare i32 @_readFileInt(i8*)

declare i9 @_readFileChar(i8*)

declare double @_readFileDouble(i8*)

declare void @_closeFile(i8*)

define i32 @fibonacci(i32 %n) {
  %1 = icmp eq i32 %n, 0
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  br label %29

; <label>:3                                       ; preds = %0
  %4 = icmp eq i32 %n, 1
  br i1 %4, label %5, label %6

; <label>:5                                       ; preds = %3
  br label %29

; <label>:6                                       ; preds = %3
  %7 = icmp ne i32 %n, 0
  %8 = icmp ne i32 %n, 1
  %9 = or i1 %7, %8
  br i1 %9, label %10, label %28

; <label>:10                                      ; preds = %6
  %11 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %n, i32 1)
  %12 = extractvalue { i32, i1 } %11, 1
  br i1 %12, label %13, label %14

; <label>:13                                      ; preds = %10
  call void @_abort(i32 12, i32 7, i32 57)
  unreachable

; <label>:14                                      ; preds = %10
  %15 = extractvalue { i32, i1 } %11, 0
  %16 = call i32 @fibonacci(i32 %15)
  %17 = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %n, i32 2)
  %18 = extractvalue { i32, i1 } %17, 1
  br i1 %18, label %19, label %20

; <label>:19                                      ; preds = %14
  call void @_abort(i32 12, i32 7, i32 74)
  unreachable

; <label>:20                                      ; preds = %14
  %21 = extractvalue { i32, i1 } %17, 0
  %22 = call i32 @fibonacci(i32 %21)
  %23 = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %16, i32 %22)
  %24 = extractvalue { i32, i1 } %23, 1
  br i1 %24, label %25, label %26

; <label>:25                                      ; preds = %20
  call void @_abort(i32 12, i32 7, i32 61)
  unreachable

; <label>:26                                      ; preds = %20
  %27 = extractvalue { i32, i1 } %23, 0
  br label %29

; <label>:28                                      ; preds = %6
  call void @_abort(i32 1, i32 5, i32 17)
  unreachable

; <label>:29                                      ; preds = %26, %5, %2
  %30 = phi i32 [ 0, %2 ], [ 1, %5 ], [ %27, %26 ]
  ret i32 %30
}

define void @readNum() {
  %num = alloca i32
  store i32 0, i32* %num
  %1 = call i32 @_readIntStd()
  store i32 %1, i32* %num
  %2 = load i32* %num
  %3 = icmp sge i32 %2, 0
  %_resPrereadNum = alloca i1
  store i1 %3, i1* %_resPrereadNum
  br i1 %3, label %5, label %4

; <label>:4                                       ; preds = %0
  call void @_abort(i32 3, i32 18, i32 17)
  br label %5

; <label>:5                                       ; preds = %4, %0
  %6 = call i32 @_writeString(i16* getelementptr inbounds ([20 x i16]* @0, i64 0, i64 0))
  %7 = load i32* %num
  %8 = call i32 @fibonacci(i32 %7)
  call void @_writeLnInt(i32 %8)
  %9 = load i1* %_resPrereadNum
  %10 = xor i1 %9, true
  %11 = or i1 %10, true
  br i1 %11, label %13, label %12

; <label>:12                                      ; preds = %5
  call void @_abort(i32 4, i32 23, i32 9)
  br label %13

; <label>:13                                      ; preds = %12, %5
  ret void
}

define void @main() {
  %1 = call i32 @_writeString(i16* getelementptr inbounds ([41 x i16]* @1, i64 0, i64 0))
  call void @readNum()
  ret void
}

attributes #0 = { nounwind readonly }
attributes #1 = { nounwind readnone }
