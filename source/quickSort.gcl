program |[

	particion : (inout arreglo : array [128] of int,in izq : int,in der : int, out res : int )
	[
		pivote, temp, i, j : int;
	]
	{pre (izq <= der) pre}
	|[ 
		i := izq;
		j := der;

		pivote := arreglo[ (izq + der) /2];
		
		{inv res = (exist k: 0≤k<i : j<k) ∧ 0≤i≤j inv} {bound j-1 }

		do (i <= j) -> 

			{inv i= (sigma k: 0<=k<arreglo[i] : 1) /\ 0<=arreglo[i]<pivote  inv} 
			{bound (pivote - arreglo[i]) bound}

			do (arreglo[i] < pivote) -> i:= i+1; od
				
				{inv j= (sigma k: 0<=k<pivote : 1) /\ 0<=pivote<arreglo[j]  inv} 
			    {bound (arreglo[j] - pivote) bound}
				
				do (arreglo[j] > pivote) -> j:= j+1; od

				if (i <= j) ->

					temp       := arreglo[i];
					arreglo[i] := arreglo[j];
					arreglo[j] := temp;
					{a i > 0 a}
					i:= i+1;
					{a j > 0 a}
					j:= j+1;
				fi

			res:= i;
		od

	|]
	{post ((forall i | izq <= i <= pivote : arreglo[i] <= arreglo[pivote]) /\
          (forall  j | pivote < j <= der  : arreglo[pivote] < arreglo[j])) post}



	quickSort : (inout arreglo : array [128] of int,in izq : int,in der : int)
	[
		indice : int;
	]
	{pre (0<=izq<=der<length(arreglo)) \/ (der < izq) pre} {bound bound}
	|[ 

		indice := particion(arreglo, izq, der);

		if (izq < indice -1) ->
			quickSort(arreglo, izq, indice -1);
		fi

		if (indice < der) ->
			quickSort(arreglo, indice, der);
		fi

	]|
	{post (forall i,j | i<=j : arreglo[i] <= arreglo[j]) post}



	|[
		desordenados : array [128] of int;
		i:= 0, j:= 0, tam:= length(desordenados) : int;	

		{inv (forall k | 0<k<=i /\ (k mod 2 =0) : desordenados[k] := 128-k) /\
			 (forall k | 0<k<=i /\ (k mod 2!=0) : desordenados[k] := 256-k) /\ 
			 0<=i<tam inv} {bound (tam - i) bound}

		do (i < tam) ->
			
			if (i mod 2 == 0) ->
				desordenados[i] = 128-i;
			[] (i mod 2 != 0) ->
				desordenados[i] = 256-i;
			fi

			i:= i+1;
		od

		quickSort(desordenados,0,127);

	    {inv true inv}
	    {bound true bound}

		do (i < tam) ->
			
			write(desordenados[i]);
			i:= i+1;
		od
	]|
]|






              